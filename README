README for PrattParserInC

These files illustrate an elegant parsing method, implemented in C/C++, first
described by Vaughn Pratt in his 1973 paper, "Top Down Operator Precedence."

Pratt's description was in Lisp, and so hard for most people to interpret. Douglas
Crockford's description in Javascript (see Beautiful Code, and 
http://javascript.crockford.com/tdop/tdop.html) were instrumental in bringing 
this method to my attention. 

They are part of a larger project, and so may not compile standalone at the moment.
These files are here to illustrate the technique, and give examples of
my code.

The file 'newpassing.l3' gives many examples of the code that is parsed with
this method.

The heart of the Pratt method is the expression() routine, that starts on line 606 of l3pratt.cpp.
As in the Crockford's paper, the algorithm is surprisingly short; it is subtle. I'll reproduce it here for easy comparison.


// Crockford's version in Javascript:

var expression = function (rbp) {
    var left;
    var t = token;
    advance();
    left = t.nud();
    while (rbp < token.lbp) {
        t = token;
        advance();
        left = t.led(left);
    }
    return left;



// My C/C++ implemention:

// working expression() parsing routine. Reproduces the original Pratt and Crockford formulation.

//
// _left holds the accumulated parse tree at any point in time.
//     "The parse Tree Up to this point, by consuming the tokens to the left" would be a better-but-too-long name.
//
//  and... _left obviously is the stuff to the left of the current operator, hence the name.
//
// data flows from token -> t -> (possibly on the stack of t recursive munch_left calls) -> into the _left tree.
//
//  better names: _left  -> _accumulated_parsed_qtree (to be returned / apqt)
//                t      -> cnode  (the current token's qtree node to be processed. Once we grab this we always advance() past it
//                                     before processing it, so that _global_next_token (or _token) contains the following token.
//
//                  actually we just keep '_token' as in, rather than this more verbose description we considered:
//                _token -> _global_next_token_node (since it is a global variable and can/will be incremented by many routines)
//
//
//  meaning of rbp parameter: if you hit a token with a  _token->_lbp < rbp, then don't bother calling munch_left, stop and return what you have.
//
// better explanation:  rbp = a lower bound on descendant nodes precedence level, so we can 
//    guarantee the precenence-hill-climbing property (small precedence at the top) in the resulting 
//    parse tree.
//
qtree* qtreefactory::expression(int rbp) {

    DV(printf("_cnode_stack has size %ld:\n", _cnode_stack.size()));
    DV(
       std::list<qtree*>::iterator be = _cnode_stack.begin();
       std::list<qtree*>::iterator en = _cnode_stack.end();
       long i = 0;
       for (; be != en; ++be, ++i) {
            printf("\n*** _cnode_stack[%02ld] = \n",i);
            (*be)->p();
        }
        printf("\n");
       );

    DV(symbol_print(_token,"_token: "));

    qtree* cnode = _token;

    if (eof()) {
        return cnode;
    }
    _cnode_stack.push_front(_token);

    advance(0);

    assert(_token);
    DV(_token->print("_token: "));

    if (cnode) {

        // munch_right() of atoms returns this/itself, in which case: _accumulated_parsed_qtree = t; is the result.
        _accumulated_parsed_qtree = cnode->munch_right(cnode);
        DV(_accumulated_parsed_qtree->print("_accumulated_parsed_qtree: "));
    }

    while(!eof() && rbp < _token->_lbp ) {
        assert(_token);

        cnode = _token;
        _cnode_stack.front() = _token;

        DV(cnode->print("cnode:  "));

        advance(0);
        if (_token) {
            DV(_token->print("_token:  "));
        }

        // if cnode->munch_left() returns this/itself, then the net effect is: _accumulated_parsed_qtree = cnode;
        _accumulated_parsed_qtree = cnode->munch_left(cnode, _accumulated_parsed_qtree);

    }

    _cnode_stack.pop_front();
    return _accumulated_parsed_qtree;
}

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

For reference, giving the theory, I attach a pdf of the Pratt original. (file: Vaughan.Pratt.TDOP.pdf)

- Jason

Jason E. Aten <j.e.aten@gmail.com>
